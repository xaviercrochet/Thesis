\chapter{Présentation du système}
\label{presentation_systeme}
\lhead{Chapitre 3 - Présentation du système}
\section{Introduction}

Ce chapitre vise, à l'aide d'un exemple concret d'utilisation,  à:
\begin{enumerate}
\item introduire les technologies utilisées pour développer l'application;
\item expliquer les différentes fonctionnalités de l'application d'un point de vue utilisateur. Les utilisateurs étant de deux types, la section relative aux fonctionnalités sera divisées en deux parties. Dans un premier temps, nous expliqueront les fonctionnalités offertes à la commission de programme à savoir;
  \begin{itemize}
    \item l'import de données dans l'application (Programmes de cours, modules, cours);
    \item la gestion des données (Accéder au différents cours, modules et programmes, mettre à jour leurs données);
    \item la gestion des contraintes;
    \item comment vérifier les programmes de cours des étudiants.
  \end{itemize}
Ensuite, nous présenterons ce qu'il est possible de faire en tant qu'étudiant avec l'application à savoir:
\begin{itemize}
  \item se créer un compte utilisateur;
  \item se connecter avec son compte utilisateur;
  \item se créer (ou modifier) un programme de cours, en choisissant le programme à suivre;
  \item configurer son programme de cours, en configurant les différentes années qui le composent et en choisissant les modules de cours à suivre;
  \item vérifier la validité de son programme;
  \item négocier avec la commission de programme la justification des exceptions. 
\end{itemize}
 
\end{enumerate}

Un des principaux objectifs de ce mémoire étant d'offrir une solution maintenable et évolutive, l'application est divisée en trois parties distinctes, indépendantes entre elles. 

Ces trois parties sont les suivantes:
\begin{itemize}
\item l'import et la mise à jour des catalogues, de programmes, modules, cours et des différentes contraintes par la \textit{commission de programme}; 
\item la création du programme par l'étudiant, via l'interface utilisateur;
\item la vérification (par l'application) des différentes contraintes induites par le programme créé précédemment par l'étudiant.
\end{itemize}

\subsection{Exemple d'utilisation}

Tout au long de ce chapitre, l'exemple suivant va être utilisé pour illustrer le fonctionnement de l'application. Il s'agit d'un catalogue de cours fictif proposant deux programmes de cours. Ce programme fictif se rapproche très fort de la réalité. Certaines parties du catalogue (certains modules optionnels du programme de master, certains cours) ont été élaguées pour rendre l'exemple plus clair. L'exemple reste néanmoins représentatif de la réalité, il comporte en effet les différents types de contraintes que l'on peut rencontrer par exemple. 
\begin{figure}
\centering
\caption{Exemple fictif de catalogue de cours}
\label{fig:running_example}
\includegraphics[width=\textwidth]{running_example}
\end{figure}

Ce catalogue est composé de deux programmes de cours.

Un programme de \textbf{Bachelier} (le grand rectangle à droite de la figure \ref{fig:running_example}) composé d'un module obligatoire (Introduction, la petite boite imbriquée s’appelant \textit{Intro})

Un programme de \textbf{Master} (le grand rectangle à gauche de la figure \ref{fig:running_example}) composé d'un module optionnel (l'option réseaux et sécurité, la boite imbriquée à gauche) et d'un module obligatoire (Le tronc commun, la boite imbriquée à droite). De plus, certains cours de master dépendent de cours de bac. 


%************************************************************
\section{Technologies utilisées}
\subsection{Introduction}
Le but poursuivit par cette section est de présenter les différents choix faits aux niveaux des technologies utilisées par l'application. Ces choix sont de deux types. Premièrement, les technologies utilisées pour construire l'application seront présentées, comme le framework ou la base de données qui est utilisée. Les technologies externes à l'application qui sont utilisées pour construire les différents curricula ou mettre à jour leur informations seront présentées par la suite.

On parle de technologie interne pour représenter celles qui sont utilisées pour développer les fonctionnalités de application. Les technologies externes sont quant à elles des applications déjà existantes qu'il faut utiliser \textbf{en dehors} de l'application et pour lesquelles il ne faut pas écrire de lignes de code.
\subsection{Ruby on Rails}
\subsubsection{Introduction}

Cette section a pour but de présenter la technologie principale utilisée pour développer l'application. Le but n'est pas de parcourir en détails le fonctionnement de Rails, mais bien d'en présenter les concepts clés. En effet, il semble important d'en comprendre les grande lignes, car son architecture, aussi bien que ses principes ont influencé la structure de la solution.
\subsubsection{Le choix d'un framework}
A première vue, l'utilisation d'un framework n'est pas absolument nécessaire. Cependant, un framework apporte toute une collection d'outils qui aident à développer mieux et plus rapidement.

\textbf{Mieux} car il permet de développer une application qui est structurée, ce qui rend le code plus maintenable et évolutif.

\textbf{Plus rapide} car il permet de gagner du temps en réutilisant des modules génériques afin de se concentrer sur d'autres domaines. Avec un framework, on assemble des briques plutôt que de réinventer la roue. 

Enfin, le dernier atout d'un framework se situe au niveau de l'intégration de nouveaux développeurs sur le projet. Dans le cadre de ce mémoire, il est clair que de nouvelles fonctionnalités devront être ajoutées dans le futur. De plus, les fonctionnalités existantes devront peut être modifiées ou améliorées. Il sera plus facile pour cette personne de se plonger dans du code qui n'est pas le sien, s'il a une structure propre aux standard web d'aujourd'hui.

\textbf{Il est donc fortement conseillé d'utiliser un framework web pour créer ce genre d'application.} 

Il en existe une multitude aujourd'hui. Il y a tout d'abord les frameworks PHP comme CakePHP, DRUPAL ou Symfony (pour ne citer que les plus connus). Viennent ensuite Ruby on Rails, un framework en ruby et Django, un framework en Python. Cette liste n'est bien entendu pas exhaustive. 
\subsubsection{Le choix de Ruby on Rails}
L'intérêt réside dans le niveau de productivité et de maintenabilité accru que l'on obtient en travaillant avec le framework. Les design patterns sous-jacents, et la philosophie de Rails permettent de concentrer son travail sur les fonctionnalités de l'application plutôt que de passer son temps à écrire du code répétitif ou remplir des fichiers de configuration. 

De plus, il existe une multitude de librairies tierces appelées \textit{ruby-gem} qui réduisent encore le nombre de lignes de code à produire, en apportant des fonctionnalités à l'application. Le meilleur exemple est \textbf{devise}, une librairie qui permet d'ajouter la gestion de l'utilisateur(création, connexion, récupération de mot de passe, envoit de mails, etc ..) en quelques lignes en plus de gérer les sessions et les accès aux différentes actions et vues. 

Rails pousse aux bonnes pratiques, c'est d'ailleurs cette philosophie qui m'a incité à développer la plupart des fonctionnalités, comme vous le verrez plus tard, dans des librairies externes à l'application.


En outre, Rails dispose d'une communauté très active et passionnée, qui teste, documente et améliore les fonctionnalités du framework. 

Les limites du framework sont les suivantes
\begin{itemize}
\item Lorsque l'on débute, on est souvent tenté de charger les modèles en voulant suivre la philosophie \textit{tiny view - skinny controller - fat model}\footnote{Bonne pratique qui consiste à délaisser toute la logique aux modèles} et l'on oublie souvent qu'il est possible de déléguer la plupart des fonctionnalités à des librairies externes, qui sont plus faciles à développer - car crées en pure \textit{ruby} - et plus facile à tester - car indépendantes de rails \cite{fat_models}.

\item Un des principaux aprioris sur les frameworks et particulièrement Ruby on Rails, est qu'il sont lents (et peu efficace). En effet, ruby est un langage interprété . Ce type de langage tend à être plus lent que les langages compilés. Cependant, il faut garder à l'esprit qu'écrire du code, trouver et corriger des bugs ou encore ajouter des nouvelles fonctionnalités dans une application sont des tâches encore plus couteuses en temps. Rails permet de réduire le temps consacré à ces tâches, ce qui est bien plus important lorsque l'on développe ou maintient une application, particulièrement dans le cadre d'un mémoire. Ainsi, à la place de configurer le mapping entre ces différentes ressources, on utilise un convention.
\end{itemize}

\subsubsection{Conclusion}
Pour toute les raisons présentées ci-dessus (libraries externes disponnibles, communauté, etc), le choix s'est naturellement porté vers Ruby on Rails. En outre, j'ai accumulé pas mal d'expérience en utilisant ce framework dans le cadre d'un stage et en réalisant des petits projets ces dernières années. 

C'est un framework open-source, utilisé pour développer des applications web. Le développement se fait à travers le langage de programmation multi-paradigmes (Programmation fonctionnelle, orientée object, ...) \textbf{ruby}. Il se base sur des puissants design patterns et principes qui vont être présentés en quelques lignes ci-dessous.

\subsubsection{DRY - Don't repeat yourself}
Comme son nom l'indique, ce premier principe pousse à la réutilisation du code existant le plus souvent que possible, plutôt que d'avoir des bouts de code similaires un peu partout dans l'application. L'idée de tendre vers une structure \textit{Api}, où tout ce qui n'est pas nécessaire aux classes et méthodes externes est caché en interne. Le principal avantage se situe au niveau de la \textbf{maintenabilité}. On évite ainsi de devoir partir à la recherche des différents bouts de code dupliqués lorsque l'on veut modifier le comportement d'une méthode, d'une classe, ou même d'un module.

\subsubsection{CoC - Convention over Configuration}
L'idée est de réduire au minimum les décisions à prendre avant de commencer à développer. Une convention importante en \textit{Ruby on rails} se situe au niveau des noms des classes pour lesquelles il existe une table correspondante en base de données. Pour un modèle \textit{Course} par exemple, la convention est d'avoir une table nommée \textit{courses} en base de données. Cela permet d'éviter d'avoir à écrire du code supplémentaire pour spécifier à l'application quelle table correspond à quel objet. 

Cela permet au développeur de se concentrer sur les parties non conventionnelles de l'application, comme l'architecture, plutôt que de perdre son temps à configurer les objets. L'avantage ici se situe plus au niveau de la \textbf{productivité}.
\subsubsection{MVC - Model-Vue-Controlleur}

Le framework s'appuie sur le pattern \textbf{MVC}. Destiné aux applications dites \textit{interactives}, il divise l'application en trois parties; le modèle, les vues et le contrôleur. Notez que \textit{Ruby on Rails} ne respecte pas totalement MVC dans sa conception initiale. Cela se justifie par le fait que ce pattern n'est pas destiné à la base aux applications web, notamment car la vue est ici une page web. Le modèle ne peut donc pas lui envoyer tous les changements qui surviennent au niveau des données. C'est la vue, qui doit expressément faire les requêtes pour ces données, à travers le contrôleur.

MVC à la sauce Rails se présente comme suit. Nous avons

\begin{description}
\item[le modèle] lié à une base de données, qui contient les données et l'état de l'application. Il contient aussi tout les objets métiers \footnote{Objets qui font tout le travail.}, qui détermine comment l'information est créée, mise à jour, et affichée;
\item[les vues] qui génèrent l'interface utilisateur et lui présentent les données. Ce composant est passif, il ne traite aucune information. \textit{Vues} est au pluriel ici, car plusieurs vues peuvent avoir accès au même modèle;
\item[le contrôleur] qui reçoit les événements du monde extérieur, interagit avec le modèle et choisit la vue à afficher à l'utilisateur. Par exemple, lorsque l'utilisateur veut éditer un commentaire dans un blog, le contrôleur va rendre la vue relative à l'édition de l'objet correspondant. 
\end{description} 

\subsubsection{Active Record}
Ce pattern quant à lui stocke les données dans une base de données relationnelle. Il s'agit simplement de fournir une abstraction supplémentaire à la base de données et fournir des fonctions pour manipuler les données. Dans le cas de rails, il y a donc une couche ruby entre la base de données proprement dite et la logique dans notre modèle. Cela permet par exemple, d'être indépendant du système de base de données utilisée en dessous.  Par exemple, \textit{postgresql} est le système de gestion de base de données utilisé pour le moment (source : \cite{rails_cast_migration_to_postgresql}. Si pour une raison X ou Y, il devient nécessaire de passer à \textit{sqlite3}, il suffit de changer le fichier de configuration \textit{config/database.yml} de
\begin{lstlisting}
development:
  adapter: postgresql
  database: db/development
  pool: 5
  timeout: 5000
\end{lstlisting}
vers
\begin{lstlisting}
development:
  adapter: sqlite3
  database: db/development
  pool: 5
  timeout: 5000
\end{lstlisting}

Et de recréer la base de données avec
\begin{lstlisting}
rake db:create:all
rake db:migrate
\end{lstlisting}



Tout cela est fait sans devoir changer comment sont accédées les données dans les différents modèles.  

\subsection{Base de données - PostgreSQL}

Rails supporte plusieurs systèmes de gestion de base de données : PostgreSQL, MySQL, SQLite. Le choix du système est cependant restreint à la plateforme utilisée pour héberger l'application (Heroku). En effet, il est nécessaire d'avoir une base de données PostgreSQL pour pouvoir héberger l'application sur Heroku. 

\subsection{Éditeur de graphes - yEd}
\label{yed}
Comme expliqué plus tard dans la section \ref{data_mgmt} détaillant comment sont importés les données, le choix s'est porté vers une importation en deux étapes des données dans l'application. 

\textbf{La première étape} consiste à créer et importer le graphe de cours. Les données importées durant cette étapes sont les nom identifiant les différents objets du graphes (cours, programme, podule), la structure des différents programmes de cours (les cours et modules constituant les programmes de cours) et les dépendances entre les cours.\footnote{Se référer à la section \ref{dependances} (relative aux dépendances) pour plus de détails.}

\textbf{La deuxième étape} consiste à ajouter des nouvelles données des différents objets (ou les mettre à jour) à l'aide d'un formulaire excel. Cela permet d'ajouter des propriétés comme les crédits d'un cours ou les crédits minimum requis d'un programme de cours par exemple.\footnote{Se référer à la section \ref{properties} pour plus de détails.} 

Le but de cette section est d'expliquer les choix qui on été faits aux niveau des technologies utilisées pour s'occuper de \textbf{la première étape} (La construction d'un graphe). 

Pour construire et importer le graphe de cours, plusieurs alternatives se sont présentées.

La première correspond à un logiciel intégré dans l'application, qui permet de construire explicitement un catalogue de cours sous forme de graphe, en proposant exclusivement de placer des objets cours, modules, ou programmes sur le graphe et en n'offrant que des arrêtes de type corequis ou prérequis. Cette application communiquerait directement avec les modèles et permettrait de générer directement les objets (cours, modules, ...) désirés. Cependant il n'existe pas d'applications réalisant ce genre de graphe pour le moment. Il faudrait donc développer un outil, intégré dans l'application,  fournissant ces fonctionnalité. Cependant, cela sort du cadre de ce mémoire, faute de temps. 

La deuxième alternative serait d'intégrer un outil générant des graphes plus standard dans l'application. YWorks offre une solution, yFiles, qui est permet la création et l'édition de graphes en HTML5 et en javascript. Ce logiciel est cependant très chère.

La troisième et dernière alternative serait d'utiliser un logiciel externe à l'application pour générer ces graphes. Ce logiciel, en plus d'être gratuit, doit être multi-plateformes (Mac os x, Linux \& Windows) et capable d'exporter dans un format relativement facile à parser. La liste de ce genre de logiciel est assez longue (Dia, Yed, OmniGraffle, Graphiz)
\begin{itemize}
  \item Dia - C'est un logiciel assez léger qui est capable d'exporter en Xml, un format standard pour représenter des données. Il devient cependant très ennuyeux à utiliser lorsque l'on manipule des graphes de taille importante. C'est cependant un éditeur graphique très générique qui n'est pas seulement destiner à la création de graphes. 
  \item OmniGraffle - Ce logiciel n'est disponible que sur Mac Os X malheureusement.
  \item Yed - Ce logiciel est assez complet. Il est cross-plateforme et à l'avantage de contenir des algorithmes qui permettent de restructurer automatiquement les graphes. Il permet aussi d'exporter en deux formats de types xml (Graphml \& XGml)
  \item (...)
\end{itemize}

Étant donné la contrainte de temps imposé par le cadre du mémoire, le choix s'est porté vers un logiciel déjà existant. Il a été préférable de choisir une solution externe pour éviter de surcharger l'application avec de lourds modules graphiques. De plus, intégrer ce genre de logiciels dans l'application ne changeait rien au fait qu'il fasse parser le fichier exporté par l'outil pour importer les données dans l'application.

YEd a été choisi pour toutes ces raisons. 
\clearpage
%*********************************************************************************************************************************$
\section{Conception}
\subsection{Introduction}
 
L'application est la  plateforme qui tient le rôle d'intermédiaire entre la commission et les étudiants. Elle est représentée par l'entité \textit{Application} sur le diagramme \ref{fig:desired_process_2}. Il y a trois modules attachés à cette entité.

\begin{figure}
\centering
\caption{Processus désiré}
\label{fig:desired_process_2}
\includegraphics[width=\textwidth]{desired_process}
\end{figure}

\textbf{Le module d'import de données} - Il permet à la commission d'importer les données liées aux curricula  à l'aide de plusieurs supports (qui seront expliqués en détail plus loin dans le chapitre). Ce module permet tout d'abord d'ajouter considérablement plus d'informations dans le support confié à l'étudiant pour qu'il construise son programme. Ensuite, il permet à la commission de mettre à jour facilement ces informations. 
 
\textbf{Le module de gestion des contraintes} - Il vérifie la validité des programmes créés par les étudiants. L'intérêt de ce module est de réduire considérablement  le temps que doit consacrer la commission à la correction des programmes d'étudiants. Premièrement, il contraint les étudiants à justififier les contraintes qui ne sont pas respectées avant d'envoyer leur programme à la validation s'il n'est pas correct. Il fourni aux étudiants un compte-rendu en temps réel de l'état de leurs programmes, en leur pointant les parties qui ne respectent pas les contraintes, quelles contraintes ne sont pas respectées et ce qu'il faut changer dans leur programme pour y remédier.

\textbf{La base de données} - Elle stocke les informations liées aux curricula enregistrés précédemment par la commission, mais aussi les programmes des étudiants. La commission pourra avoir accès aux anciens programmes de cours et à touts les programmes des étudiants. Ces derniers quant à eux, pourront accéder aux différents programmes qu'ils ont déjà suivis et avoir une vision claire de ce qu'il leur reste à valider pour obtenir leur diplôme.

Les fonctionnalités de l'application, telles qu'elles apparaissent sur la figure \ref{fig:desired_process} vont être expliquées dans les sous-sections qui suivent.

\subsubsection{Lexique}
\label{lexique}
Avans de poursuivre l'explication des fonctionnalités de l'application, cette sous-section va expliquer les différents objets qui sont utilisé tout au long de ce chapitre.
\begin{description}
\item[Catalogue] Cet objet est la représentation d'un graphe généré avec yEd une fois importé en base de données. Un catalogue est constitué de plusieurs programmes, modules et cours et est identifié par l'année académique pour laquelle il est destinné. 
\item[Programme] C'est la représentation d'un programme de cours (SINF2M, INFO2M, ...).
\item[Module] C'est un ensemble de cours qui peut être obligatoire (Le tronc comun du programme SINF2M) ou optionnel (les options du programme SINF2M).
\end{description}
\subsection{Gestion des données}
\label{data_mgmt}
Cette section explique comment sont importées les données relatives aux programmes, leurs cours, leurs informations et leurs différentes contraintes. 

Les différentes informations contenues dans chacun des programmes proposés sont les suivantes. Nous avons:
\begin{itemize}
\item plusieurs programmes de cours (SINF1BA, FSA1BA, SINF1PM SINF2M SINF2M1 et INFO2M);
\item chacun de ces programmes contiennent des modules et des cours, avec des informations relatives aux cours et modules obligatoires;
\item chacun de ces cours peut avoir des dépendances \footnote{Se référer à la section \ref{contraintes_intro} et la section \ref{contraintes} pour plus de détails sur ces contraintes};
\item chaque cours, module et programme contient des propriétés. (Le nombre de crédits d'un cours, le semestre durant lequel il est dispensé, l'obligation de suivre un module, le nombre de crédits minium et maximum d'un programme ou module).
\end{itemize}

Il n'est pas viable pour la commission de programme d'ajouter ces informations une à une à l'aide de formulaires permettant d'ajouter et de modifier ces différents objets. Cette approche malgré qu'elle soit facile à mettre en place, contraint la commission de programme à de longues et fastidieuses séances d'encodage de programmes. Qui plus est, chacun des programmes de cours proposés a la forme d'un graphe. La solution la plus logique est donc d'utiliser un éditeur graphique pour construire les différents programme de cours.

La démarche qui a amené à utiliser le logiciel yEd, pour importer la structure des programmes de cours, est expliquée en détail dans la section \ref{yed}. Cette solution a deux conséquences;

\begin{enumerate}
  \item Le logiciel étant externe à l'application, il est nécessaire d'exporter le graphe vers un fichier. Ensuite, il faut parser ce fichier pour en extraire les informations.
  \item On est restreint dans les données que l'on peut ajouter dans un graphe. Ces informations se limitent aux différents labels des nœuds et à leurs dépendances. Une solution est requise pour ajouter les données manquantes. 
\end{enumerate}

Pour \textbf{le premier point}, il a été décidé d'exporter le graphe dans le format \textit{GraphML} (une extension de XML destinée aux graphes). Les informations contenues dans ce fichier sont extraites par l'application à la création du catalogue. Plusieurs formats étaient disponibles pour exporter le graphe créé avec yEd, les raisons qui ont mené à utiliser le format GraphML sont expliquées en détail dans la section \ref{graph_format_justification}.

Les détails de l'implémentation concernant le module qui s'occupe d'extraire les informations contenues dans les graphes sont disponibles dans la section \ref{graph_parsing}.

\textbf{Le deuxième point} justifie le fait que l'importation des données se fait en deux étapes (la première étant l'import du fichier de graphe). Les données manquantes après l'import du graphe sont les suivantes:

\begin{itemize}
  \item les propriétés d'un cours; son sigle (INGI1101 par exemple), le semestre durant lequel il est dispensé, le nombre de crédits, le fait qu'il soit obligatoire;
  \item les propriétés d'un module; son nom, le nombre de crédits minimum et maximum requis pour le valider;
  \item les propriétés d'un programme de cours; son nom, le nombre de crédits minimum et maximum requis pour le valider.
\end{itemize}

La liste de ces propriétés n'est pas exhaustive. Il se peut qu'à l'avenir, le besoin se fasse sentir d'ajouter des informations comme le nom d'un professeur, l'URL du cours, ou toute autre information nécessaire pour des contraintes qui n'ont pas été prévue lors de la conception de l'application. C'est pourquoi en plus de pouvoir d'ajouter et mettre à jour ces informations, il doit être possible d'ajouter des nouvelles propriétés.

Excel a été choisi pour ajouter toutes ces informations car:
\begin{itemize}
  \item il est disponible sur toutes les plateformes (Mac OS, Windows, Linux);
  \item il est facile d'utilisation;
  \item il permet de gérer des grandes quantités d'information de façon structurée;
  \item le format vers lequel il exporte est très facile à parser (XLS)
\end{itemize}

\subsubsection{Conclusion}
L'import de toutes les données se fait en deux étapes. La première consiste à importer le graphe de cours, contenant le nom de chacun des cours, modules et programmes, en plus de leur structure (les cours et modules inclus dans chaque module et programme) et des dépendances entre les cours. Ces informations ne sont pas modifiables une fois le catalogue de cours créé. En cas d'erreure, il n'est pas possible (pour le moment) de mettre à jour les données en téléchargant une nouvelle version du graphe de cours. Il faut donc supprimer le catalogue de cours puis le recréer avec la nouvelle version du graphe.

Les explications relatives aux conventions à utiliser lorsque l'on crée un graphe avec yEd sont disponnibles dans le manuel en annexe.  

La deuxième étape quant à elle, consiste à importer le reste des données dans l'application, via un formulaire excel. Cette étape est répétable, à tout moment les données peuvent être mises à jour sans mettre en péril le fonctionnement de l'application. De plus, il n'y a pas de limites aux informations que l'on peut ajouter de cette manière dans le sens où l'on pourrait rajouter tout et n'importe quoi comme informations (pour peu que l'on vérifie les conventions d'import de formulaire excel) sans faire crasher l'application. 

Cependant, on pourrait, en procédant de la sorte ajouter des incohérences, surtout si l'on modifie les informations relatives aux contraintes. Par exemple, si on ajoute un minimum de crédits à un module qui est plus grand que le maximum de crédits du programme dans lequel il se trouve, il serait impossible pour un étudiant de créer un programme valide.


Les explications relatives aux convetions à utiliser lorsque l'on complète le formulaire Excel sont disponnibles dans le manuel en annexe. 

Par souci de modularité, ces deux étapes sont implémentées dans des modules externes à l'application, comme expliqué dans le chapitre relatif au développement du système \ref{developpement_system}. L'application est relativement indépendante de ces modules, dans le sens ou il serait relativement aisé d'ajouter une méthode encore plus pratique pour ajouter toutes ces informations, sans devoir modifier tout le reste de l'application. Par exemple, on pourrait ajouter manuellement sans passer par ces deux étapes; il suffirait d'implémenter les vues (formulaires de création) correspondantes dans l'application. 




\subsection{Contraintes}
\label{contraintes}
Comme présenté dans la section précédente \ref{contraintes_intro}, les contraintes sont de plusieurs types. Le but de cette section est de présenter les choix que cette catégorisation impose de faire au niveau de la conception des fonctionnalités et d'expliquer plus en détails la logique intrinsèque des plus compliquées d'entre elles.    

Comme expliqué dans les sections qui suivent, la location des informations relatives aux contraintes (les crédits et les dépendances d'un cours par exemple) n'est pas la même pour toutes les contraintes. Qui plus est, chaque contrainte n'est pas vérifiée de la même façon. Une dépendance par exemple implique d'aller chercher si un cours est présent dans un programme, alors que le minimum de crédits requis d'un programme implique de compter les crédits de chacun ces cours. Enfin, chaque contrainte ne renvoie pas les même informations lorsqu'elle n'est pas valide (il faut renvoyer le cours le type de dépendance et le cours lié à la dépendance lorsqu'elle n'est pas valide par exemple). 

 
Dès lors, pour ne pas surcharger les modèles de l'application et la rendre plus flexible (et ainsi conserver un faible couplage et une haute cohésion), la vérification de ces contraintes a été déléguée à un module externe. On évite, ainsi, de se retrouver avec des modèles dont la taille se chiffre en milliers de lignes de code qui sont très difficile à maintenir et faire évoluer. 
\subsubsection{Dépendances}
\label{dependances}
Comme expliqué précédemment les dépendances peuvent être des prérequis ou des corequis. En plus de cela, ces contraintes peuvent être:
\begin{description}
\item[binaires]; elles concernent deux cours; un cours \textit{source} et un cours \textit{destination}; le sens de la contrainte étant celui de la flèche (le cours source est le prérequis du cours destination par exemple);
\item[n-aire]; elles sont composées de plusieurs cours \textit{sources} et de plusieurs cours \textit{destinations}.
\end{description}
 
Pour chaque ensemble n-aire de dépendances, il existe une condition qui s'applique sur chacune des dépendances qui le constitue. Cette condition est soit une disjonction (OR), soit une disjonction exclusive (XOR). L'effet de la condition est la suivante. Il n'y a pas de représentation explicite pour les conjonctions de dépendances car elle peuvent être représentées simplement par des relations binaires.

\begin{itemize}
\item Une contrainte disjonctive ne sera valide que s'il existe au moins une des sous-contraintes qui est vraie.
\item Une contrainte disjonctive exclusive ne sera valide que s'il n'existe qu'une et une seule des sous-contraintes qui est vraie.
\end{itemize}

Il y a un exemple de chaque cas qui se trouve dans l'exemple fictif \ref{fig:running_example}. La contrainte disjonctive se trouve dans le programme de Bachelier. La contrainte disjonctive exclusive quant à elle se trouve dans l'option Réseau et Sécurité du programme de Master.

\begin{figure}
\centering
\caption{Contrainte n-aire disjonctive}
\label{fig:nary_or_constraint}
\includegraphics[scale = 0.7]{nary_or_constraint}
\end{figure}


Sur l'image \ref{fig:nary_or_constraint} apparait en détail la contrainte disjonctive;
\begin{itemize}
  \item \textit{SINF1252} et \textit{INGI1131} sont les cours \textit{destinations}
  \item \textit{SINF1101} \textit{SINF1103} et \textit{FSAB1401} sont les cours \textit{sources}
\end{itemize}

Ces contraintes étant des prérequis, il est donc nécessaire d'avoir suivi et réussi \textit{SINF1103} \textbf{OU} (OR) \textit{SINF1101} \textbf{OU}(OR) \textit{FSAB1401} pour pouvoir suivre \textit{SINF1252} \textbf{OU}(OR) \textit{INGI1131}

Sur l'image \ref{fig:nary_xor_constraint} apparait en détail une contrainte disjonctive exclusive;

\begin{itemize}
\item \textit{INGI2349} est le cours \textit{destination};
\item \textit{INGI2145}, \textit{INGI2142}, \textit{INGI2143} et \textit{INGI2347} sont les cours sources.
\end{itemize}

Ces contraintes étant des corequis, il est donc nécessaire d'avoir suivit au plus tard la même année un et un seul des cours \textit{sources} pour pouvoir suivre le cours \textit{INGI2349}. Si l'on suit deux, trois ou la totalité des cours \textit{sources}, la contrainte en sera pas valide!

\begin{figure}
\centering
\caption{Contrainte n-aire disjonctive exclusive}
\label{fig:nary_xor_constraint}
\includegraphics[scale=0.7]{nary_xor_constraint}
\end{figure}

Notez que les dépendances sont importées à l'aide du logiciel yEd \ref{yed}. Il n'est donc pas possible de les modifier, pour le moment, une fois le graphe importé dans l'application. Dans l'état actuel des choses, si l'on désire modifier la structure d'un catalogue de cours (çàd sont graphe), il faut recréer le catalogue de cours avec le graphe modifié. Nous perdons cependant toute les informations additionnelles ajoutées via l'import de formulaires Excel. La mise à jour de la structure d'un catalogue de cours est une des améliorations à apporter à l'application, comme présenté dans le chapitre \ref{futur_work} relatif aux travaux futurs.
\subsubsection{Contraintes s’exerçant sur les propriétés des cours, modules et programmes}
\label{properties}
Ces contraintes regroupent plusieurs catégories de contraintes au sens où elles on été présentées dans le chapitre \ref{contraintes_intro}. On dit que ces contraintes portent sur des propriétés car leur validité dépend de l'information contenue dans celles-ci. Pour reprendre l'exemple du minimum de crédits requis pour valider un programme de cours. La validité de cette contrainte dépend (en plus des cours et modules qui composent ce programme) de deux choses:
\begin{enumerate}
  \item la valeur de cette propriété MIN, contenue dans la propriété du même nom de l'objet Programme;
  \item la valeur de la propriété CREDITS qui compose chacun de ses cours
\end{enumerate}

Par exemple, si le module \textit{Réseau et Sécurité} de l'exemple \ref{fig:running_example} comporte la propriété \textit{MIN, 15}, la méthode qui vérifie les contraintes sur les propriétés de type \textbf{MIN} va aller compter un à un les crédits de chacun des cours qui compose le module, ainsi que chacun des cours qui composent chacun de ses sous-modules (le module intitulé \textit{Cours obligatoires} ici).

Le module de contraintes n'a pas la charge de vérifier tous les types de contraintes. Dans le cas de la contrainte temporelle sur les semestres (qui implique qu'un cours doit être suivit durant le semestre au cours duquel il est dispensé), la vérification est implicite. En effet, la configuration de chaque année se faisant par semestre, il n'est pas possible pour un étudiant de choisir un cours, pour un semestre donné, qui n'est pas dispensé pendant ce semestre. 

Les données relatives à ces propriétés sont importées et mises à jour par le module qui s'occupe d'importer les formulaires Excel. Elle peuvent donc être, contrairement aux dépendances, modifiées quand on le souhaite.  


%*****************************************************
\clearpage
\subsection{Fonctionnalités de l'application - Commission de programme}
\subsubsection{Introduction}
 Une fois connecté à l'aide du compte admin, nous arrivons à la page illustrée sur la figure suivante \ref{fig:landing_page_admin}. Quatre menus sont accessibles depuis la barre de navigation (en haut dans la page d’accueil):
 \begin{description}
  \item [Catalogue] Ce menu offre l'accès à la gestion des catalogues. C'est ici que les catalogues sont importés (via le graph yEd) et mis à jour (via le formulaire Excel). Ce menu permet aussi de gérer les versions des catalogues, pour permettre de mentionner quel est le catalogue principal (celui qui sera utilisé par défaut par les étudiants), quels sont les anciens catalogues (Pour permettre aux étudiants d'avoir accès aux anciens programmes de cours) et quels sont les futurs catalogues qui, toujours en construction, ne sont pas accessibles aux étudiants. 
  \item [Demandes de validation] Ce menu offre l'accès aux requêtes de validation envoyées par les étudiants. La commission de programme aura accès ici au programme d'étudiant lié à la demande de validation, à l'état de celui-ci (est il valide?) et à ses justifications en cas de contraintes non vérifiées dans son programme. C'est ici que la commission de programme accepte ou refuse les programmes d'étudiants.
  \item [Gérer les années] Ce menu offre la possibilité à la commission de marquer les années comme réussies ou ratées (en choisissant les cours réussis). 
  \item [Discussions] Ce menu permet d'accéder aux différentes discussions qui apparaissent lors du processus de négociation entre la commission de programme et les étudiants, lorsque ces derniers sont amenés à justifier les exceptions éventuelles qui surviennent dans leur programme de cours. 
  \end{description}
\begin{figure}
\caption{Page d’accueil}
\label{fig:landing_page_admin}
\includegraphics[width=\textwidth]{landing_page_admin}
\end{figure}

%**********************************************
\subsubsection{Encoder et mettre à jour les programmes de cours}
L'ajout de nouveaux programmes de cours se fait en deux étapes dans l'application (comme expliqué dans la section \ref{yed}). La première étape correspond à l'import du graphe créé avec yEd. Cette étape importe dans la base de données les différents programmes de cours, leurs modules, leurs cours et les dépendances entre ces cours.

Cependant, les informations ajoutées par l'intermédiaire de cette étape ne sont pas suffisantes. Il manque toutes les propriétés des différents objets qui, en plus d'être des compléments d'information, servent pour certaines contraintes comme expliqué dans la section précédente \ref{contraintes}. C'est pourquoi il existe une deuxième étape qui permet d'importer un formulaire Excel contenant les informations complémentaires des différents cours, modules et programmes (le nombre de crédits minium et maximum d'un programme, le nombre de crédits d'un cours, le semestre durant lequel il est dispensé). 


Reprenons  l'exemple \ref{fig:running_example}. Les différents programmes de cours sont importés dans l'application par l'intermédiaire d'un module important les graphes yEd. Un catalogue de cours représente l'ensemble des programmes de cours présent sur le graphe \ref{fig:running_example}. Le formulaire suivant \ref{fig:catalog_new_page} permet de créer ces catalogues. 

\begin{figure}
\centering
\caption{Création d'un nouveau catalogue de cours}
\label{fig:catalog_new_page}
\includegraphics[width=\textwidth]{catalog_new}
\end{figure}


L'utilisateur peut choisir l'année académique et le nom qui vont identifier le catalogue de cours. Cette différenciation est importante car l'application gère plusieurs version de catalogues. Ces versions sont de trois types: 

\begin{enumerate}
\item la version principale; cette version correspond au catalogue qui sera utilisé par défaut par les étudiants. Il ne peut avoir qu'un seul catalogue principal dans l'application. Lorsqu'un étudiant crée un compte utilisateur, il suit par défaut le catalogue principal. Un utilisateur peut cependant choisir un autre catalogue parmi les version anciennes. 
\item les anciennes versions; ces versions correspondent aux anciens catalogues principaux; à chaque fois qu'un catalogue est élu ``principal'', la version du catalogue principal devient ancienne; il n'y a pas de limites sur le nombre de catalogues anciens;
\item les version futures; ces versions correspondent aux nouveaux catalogues créés par la commission de programmes, qui ne sont pas encore disponibles aux étudiants; il n'y a pas de limites sur le nombre de catalogues futurs et ils ne sont pas accessibles aux étudiants. 
\end{enumerate}

\label{catalog_version}
La version d'un catalogue de cours évolue comme suit. À sa création il a la version \textit{future}. Ensuite il passe à la version \textit{principale} lorsque la commission le décide. Enfin, il passe à la version \textit{ancienne} lorsqu'un autre catalogue est \textit{élu} \textit{principal}. 

L'ajout, la modification et la récupération des informations relatives aux cours, modules et programmes se fait par l'intermédiaire d'un module d'import de fichiers Excel. Les consignes pour présenter les données sont expliquées en détails dans le manuel présent en annexe. Pour plus de facilité, il est possible de télécharger directement un template de ce formulaire depuis l'application. La structure reconnue par le module d'import est présente dans ce template, ainsi que le nom des différents cours, modules et programmes présents dans la base de données. De plus, il y a aussi, pour chaque type d'objet (cours, modules et programmes) des exemples de propriété. 

Reprenons l'exemple fictif illustré sur l'image \ref{fig:running_example}. Lorsque l'on crée un catalogue avec ce graphe, et que l'on télécharge juste après le formulaire Excel, on obtient les informations suivantes.

\begin{itemize}

\item Sur la page des programmes (Figure \ref{fig:excel_programs_ex}), les propriété relatives aux nombres minimum et maximum (MIN et MAX) de crédits d'un programme sont proposées.

\item Sur la page des modules (Figure \ref{fig:excel_modules_ex}), les propriétés relatives aux nombres minimum et maximum (MIN et MAX) de crédits d'un module sont proposées. De plus, on peut aussi spécifier si le module est obligatoire ou non.

\item Sur la page des cours (Figure \ref{fig:excel_courses_ex}), les propriétés relatives au semestre durant lequel le cours est dispensé sont notamment proposée, ainsi que la propriété \textit{obligatoire} d'un cours. 

\end{itemize}

La liste de ces propriétés n'est pas exhaustive. En effet il suffit, pour rajouter une nouvelle propriété, de simplement l'ajouter dans le formulaire. Le module d'import de données se chargera de créer les propriétés correspondantes si elles ne sont pas vide dans le formulaire. 

Pour afficher les nouvelles propriétés, il suffit de les afficher dans la vue correspondante (se rendre dans la page cours\#show et récupérer l'information de la nouvelle propriété par exemple)

Pour ajouter une contrainte sur une nouvelle propriété il faut;
\begin{itemize}
\item ajouter la classe correspondante dans le module de contraintes;
\item créer l'objet de cette classe dans le modèle correspondant;
\item traiter les informations (de la nouvelle contrainte) renvoyées par le module de contraintes;
\end{itemize}

Les détails d'implémentation des nouvelles contraintes sont expliquées dans la section \ref{constraint_mgmt}. 

\begin{figure}
\centering
\caption{La page relative aux programme d'un template de formulaire}
\label{fig:excel_programs_ex}
\includegraphics[width=\textwidth]{excel_programs_ex}
\end{figure}

\begin{figure}
\centering
\caption{La page relative aux cours d'un template de formulaire}
\label{fig:excel_courses_ex}
\includegraphics[width=\textwidth]{excel_courses_ex}
\end{figure}

\begin{figure}
\centering
\caption{La page relative aux modules d'un template de formulaire}
\label{fig:excel_modules_ex}
\includegraphics[width=\textwidth]{excel_modules_ex}
\end{figure}

\begin{figure}[!htb]
\centering
\caption{Un catalogue de cours après sa création}
\label{fig:catalog_show}
\includegraphics[width=\textwidth]{catalog_show}
\end{figure}

Toutes ces fonctionnalités sont accessibles depuis la page telle qu'elle est illustrée sur l'image \ref{fig:catalog_show}. Le menu déroulant du bas permet d'accéder aux différents programmes, modules et cours du catalogue (le tout, sans devoir recharger la page). En haut à gauche apparaissent les trois propriétés identifiant notre catalogue, à savoir son nom, son année académique et sa version. 

En naviguant dans les différents sous-menus du catalogue (cours, programmes, modules), vous pouvez accéder aux informations complètes concernant ces objets. Il est possible par exemple d'accéder aux détails des contraintes d'un cours. Il est notamment possible de créer des programmes de cours \textit{customisés} à partir des informations présentes dans le catalogue (cours, modules). On pourrait donc par exemple créer un programme \textit{Erasmus} ou \textit{Mercator} avec les modules et cours disponibles, pour proposer aux étudiants étrangers un programme de cours adapté à leur profil.

%***********************************************
\subsubsection{Gérer les années des étudiants}
\label{year_mgmt}
Bien qu'elle ne soit pas mentionnée sur le diagramme \ref{fig:desired_process}, la fonctionnalité qui permet à la commission de programme de marquer les années des étudiants comme réussie, ou comme ratée (en sélectionnant les cours réussis) est relativement importante pour le bon fonctionnement du module qui s'occupe de vérifier les contraintes. 


En effet, pour vérifier la validité des contraintes de type \textit{dépendance} (se référer à  la section \ref{dependances} pour plus de détails), il est nécessaire de différencier les années réussies des années ratées, et de différencier, dans ces années ratées, les cours crédités des cours ratés. Ainsi, le module qui vérifie les contraintes ne prendra pas en compte un cours qui est présent dans une année mais qui n'a pas été crédité lorsqu'il vérifiera certaines contraintes. Par exemple, lorsque l'on vérifie si le nombre de crédits minimum d'un module est atteint, ou si le prérequis d'un cours est valide, il ne faut pas prendre en compte les cours qui n'ont pas été crédités. 

Pour les mêmes raisons, il est primordial de garder une trace des années ratées de l'étudiant, pour savoir quels cours l'étudiant a validé durant cette année qu'il n'a pas réussie.

On peut donc gérer sur la page \ref{fig:year_mgmt} les années des étudiants. Marquer une année comme réussie ou ratée empêchera à l'avenir l'étudiant de modifier ou de supprimer son année dans la page de gestion de son programme. Pour marquer son année comme ratée, il suffit de sélectionner les cours ont été crédité (comme on peut le voir sur la figure \ref{fig:failed_year_mgmt})
\begin{figure}[!htb]
\centering
\caption{La page de gestion des années}
\label{fig:year_mgmt}
\includegraphics[width=\textwidth]{year_mgmt}
\end{figure}

\begin{figure}
\centering
\caption{Gérer une année ratée}
\label{fig:failed_year_mgmt}
\includegraphics[width=\textwidth]{failed_year_mgmt}
\end{figure}

%********************************************
\subsubsection{Gérer les demandes de validations}
Cette fonctionnalité s'occupe de gérer les étapes \textit{Négociation avec l'étudiant et Valider le programme de l'étudiant} du processus représentée sur le diagramme \ref{fig:desired_process}. 

Lorsqu'un étudiant pense que son programme est correct, il envoie une demande de validation à la commission de programme. Dans le meilleur des mondes, le programme de l'étudiant respecte toutes les contraintes imposées par le programme qu'il suit. Cependant, pour une raison X ou Y, il arrive qu'un étudiant pense avoir une bonne raison pour enfreindre une ou plusieurs contraintes.

Prenons l'exemple d'un étudiant en provenance d'une autre université qui vient suivre un programme de master à l'UCL. En regardant attentivement l'exemple fictif \ref{fig:running_example}, on s’aperçoit que le cours \textit{INGI2315} du programme de master a une dépendance (\textit{SINF1140}) dans le programme de bachelier. Lorsque l'étudiant construit son programme de MASTER, il va se trouver avec des contraintes non respectées qu'il ne sera pas possible pour lui de corriger. 

Comme expliqué dans la section relative aux fonctionnalités offertes à l'étudiant qui suit \ref{validation_request}, l'application permet à l'étudiant, sous certaines conditions (remplir une justification s'il subsiste des contraintes non vérifiées par exemple), de soumettre un programme non valide à la validation. Lorsque notre étudiant soumettra son programme, il remplira un formulaire de justification avant d'envoyer sa demande de validation.

La page qui donne accès à la commission de programme aux demandes de validations est la suivante \ref{fig:validation_mgmt}. Sur cette page, la commission de programme peut accéder aux programmes de l'étudiant (Menu Programme) et accéder à un menu qui permet de voir les contraintes non-vérifiées du programme et leur justification (Menu Exceptions). Ce dernier menu (Justification) permet aussi d'envoyer des message à l'étudiant pour demander des informations supplémentaires.

La page \ref{fig:exception_mgmt} donne accès à la justification du programme d'un étudiant. Dans cet exemple il manque, dans le programme de l'étudiant, plusieurs cours obligatoires. De plus, il a dépassé le maximum autorisé de son programme ainsi que des deux modules qui le compose. Sur cette page, la commission de programme à accès aux détails de chacune des contraintes non respectées du programme de l'étudiant. À droite de chaque contrainte non respectée se trouve la justification de l'étudiant. Comme affiché sur la page \ref{fig:exception_send_message}, la commission a aussi la possibilité d'envoyer un message à l'étudiant pour lui demander des informations supplémentaires. 

Une fois les exceptions vérifiées, la commission n'a plus qu'à valider la demander ou bien la refuser. 




\begin{figure}
\centering
\caption{Page de gestion des demandes de validation}
\label{fig:validation_mgmt}
\includegraphics[width=\textwidth]{validation_mgmt}
\end{figure}

\begin{figure}[!htb]
\centering
\caption{Les exceptions d'un programme et leurs justifications}
\label{fig:exception_mgmt}
\includegraphics[width=\textwidth]{exception_mgmt}
\end{figure}

\begin{figure}
\centering
\caption{Demander des informations supplémentaires à un étudiant}
\label{fig:exception_send_message}
\includegraphics[width=\textwidth]{exception_send_message}
\end{figure}

%*******************************************$$
\clearpage
\subsection{Fonctionnalités de l'application - Étudiant}
\subsubsection{Introduction}
Une fois connecté à l'application, l'étudiant arrive sur la page illustrée sur la figure \ref{fig:student_landing_page}. Deux menus sont accessibles dans la barre de menu en haut; 

\begin{description}
  \item[Mes programmes de cours] Ce menu permet d'accéder à la création du ou des programmes suivis par l'étudiant. C'est par ici que le module de contraintes est appelé pour vérifier la valider des programmes de cours. 
  \item[Programmes disponibles] Ce menu permet d'accéder en détail aux programmes proposés. Il est aussi possible de changer la version du catalogue utilisé via ce menu. (Les différentes versions et leur utilité est expliquée dans la section \ref{catalog_version})
\end{description}
\begin{figure}
\centering
\caption{Page d’accueil des étudiants}
\label{fig:student_landing_page}
\includegraphics[width=\textwidth]{student_landing_page}
\end{figure}

Les sous-sections suivantes expliqueront les différentes fonctionnalités offertes aux étudiants. 

%********************************************************
\subsubsection{Accéder au programmes de cours disponibles}

Lorsqu'un étudiant désire créer un programme de cours, il doit tout d'abord choisir le programme qu'il va suivre. Si nous reprenons l'exemple fictif \ref{fig:running_example}, il y a deux programmes proposés dans ce catalogue; celui de BACHELIER et celui de MASTER. Comme expliqué dans la section \ref{catalog_version}, plusieurs versions de catalogues de cours sont disponibles dans l'application. 

Pour le moment, il n'est pas possible de rendre un cours disponible dans plusieurs programmes lorsque l'on crée le graphe avec yEd. Cependant, il arrive souvent que cette situation se produise, notamment pour les programmes SINF2M et INFO2M qui ont ne nombreux cours et modules en commun. C'est pourquoi la commission, en attendant qu'une solution plus efficace soit implémentée, doit créer deux catalogues différents. Un étudiant doit donc avoir la possibilité de choisir le catalogue qu'il va suivre en fonction du type de programme dans lequel il se trouve (ingénieur civil ou sciences informatiques).

On peut voir sur l'image \ref{fig:prgrm_availables} les programmes disponibles dans le catalogue de l'exemple fictif. 

\begin{figure}
\centering
\caption{Programmes disponibles}
\label{fig:prgrm_availables}
\includegraphics[width=\textwidth]{prgrm_availables}
\end{figure}

%********************************************************
\subsubsection{Configuration d'un programme d'étudiant}
\label{prgrm_mgmt}
Un étudiant à deux choses à faire pour configurer son programme; configurer les différentes années qui le constituent et choisir les différents modules. La page illustrée sur l'image \ref{fig:program_configure} affiche les différentes fonctionnalités à la disposition de l'étudiant. 

Notez que le bouton \textit{Envoyer à la validation} est désactivé pour le moment. En effet, il n'est possible d'envoyer son programme à la validation que lorsque certaines conditions sont remplies, pour éviter que la commission de programme reçoivent des demandes de validations pas assez complètes. Les conditions requises pour pouvoir envoyer son programme à la validation seront expliquées en détail dans la section \ref{fig:validation_mgmt}. 

 
L'idée, pour construire son programme est de configurer chacune des années qui le composent et de choisir les modules correspondant, pour éliminer une à une les contraintes qui ne sont pas respectées. Si nous reprenons le diagramme \ref{fig:desired_process}, l'étape qui correspond à cette section est celle qui s'intitule \textit{Construire/Modifier son programme}.



\begin{figure}
\centering
\caption{Configuration du programme}
\label{fig:program_configure}
\includegraphics[width=\textwidth]{prgrm_configuration}
\end{figure}

La page \ref{fig:program_configure} permet d'accéder aux différent menus qui permettent de configurer un programme d'étudiant à savoir;
\begin{enumerate}
\item configurer le programme
\item accéder aux informations du programme suivit par l'étudiant
\item vérifier les contraintes et justifier celles qui ne sont pas respectés
\item mettre à niveau le programme si une nouvelle version est émise par la commission de programme
\item envoyer le programme à la validation
\end{enumerate}

La page permettant à l'étudiant de configurer une année de son programme est illustrée sur l'image \ref{fig:year_configuration}. Les cours sont affichés en fonction de leur semestre et de s'il sont obligatoires ou non. Un cours sera obligatoire s'il a été marqué comme tel via le formulaire Excel, ou si son module parent l'est aussi.

Notez que si la commission n'a pas complété les informations après avoir importé le graphe, les champs \textit{SEMESTRE} de chacun des cours ne seront pas initialisés. Aucun de ces cours ne sera affiché dans cette vue, cela, afin de permettre la vérification automatique des contraintes temporelles et éviter ainsi qu'un étudiant choisisse un cours qui n'appartient pas au bon semestre. On évite ainsi de surcharger la page de vérification des contraintes (qui est déjà fort chargée).

Tant que ces années ne sont pas marquées comme réussies ou ratées par la commission (via la fonctionnalité expliquée dans la section \ref{year_mgmt}), elles sont modifiables et même supprimables. Par contre, une fois ces années marquées, il ne sera plus possible de les modifier. 

De la même façon, il est possible de sélectionner les modules qui constituent le programme.
\begin{figure}
\centering
\caption{Configuration des années}
\label{fig:year_configuration}
\includegraphics[width=\textwidth]{year_configuration}
\end{figure}

Lorsqu'un étudiant construit un programme, il configure essentiellement les cours de l'année qu'il va suivre et fait des prévisions sur les cours qu'il pourrait suivre l'année prochaine pour qu'il ne se trouve pas dans une situation où, en troisième année de bachelier par exemple, il ne puisse pas valider son programme.

Lorsque l'étudiant reprend son programme, l'année après sa validation par la commission, il doit recommencer ce processus. Il est cependant fort probable qu'une nouvelle version du programme de cours soit émise par la commission. C'est pourquoi il est possible via le bouton \textit{Mettre à niveau le programme} de mettre à jour celui-ci avec la nouvelle version disponible. Cette fonction va mettre à jour toutes les instances des cours constituant les années qui n'ont pas encore été créditées (ou partiellement créditées dans le cas d'une année ratée) avec celles de la nouvelle version du programme de cours (et toutes leurs contraintes par la même occasion). Les années (totalement ou partiellement) créditées sont automatiquement détectées par le module de contraintes. Celui-ci s'occupe d'aller chercher les contraintes correspondantes. 

Cependant, lorsque certains cours changent de sigle, il ne sera pas possible pour cette fonctionnalité de les récupérer. Si ce cours qui change de nom est le prérequis d'un autre cours, cette situation peut devenir problématique pour l'étudiant.  En effet, l'application ne sera pas capable de retrouver l'ancienne version du cours; l'étudiant aura donc une contrainte qu'il sera impossible de corriger.  Pour gérer cette situation, il est permis à l'étudiant de soumettre des programmes qui ne vérifient pas certaines contraintes, du moment qu'ils les justifient et que la commission de programme accepte cette justification. Il suffira à l'étudiant d'expliqué, dans le champ prévu à cet effet qu'il a déjà suivit l'ancienne version du cours.


\subsubsection{Vérification des contraintes}
Le module de gestion des contraintes renvoi beaucoup d'informations à propos des choses manquantes dans le programme. La page illustré sur la figure \ref{fig:constraint_mgmt} filtre ces informations et affiche essentiellement les dépendances manquantes.

\begin{figure}
\centering
\caption{Gestion des contraintes}
\label{fig:constraint_mgmt}
\includegraphics[width=\textwidth]{constraints_mgmt}
\end{figure}

\begin{figure}
\centering
\caption{Statut du programme d'un étudiant}
\label{fig:prgrm_status}
\includegraphics[width=\textwidth]{prgrm_status}
\end{figure} 

Toute les contraintes ne sont pas affichées sur cette page. La liste complète des contraintes gérées par le module qui gère les contraintes est la suivante:
\begin{itemize}
  \item les différentes dépendances entre les cours, telles qu'elles sont présentées sur la figure \ref{fig:constraint_mgmt};
  \item les contraintes relatives au nombre de crédits (crédits totaux, crédits minimum, crédits maximum) d'un ensemble de cours (programme ou module); en plus d'être affichées lorsqu'elles ne sont pas respectée, un menu récapitulatif (montrant la progression en terme de crédits du programme) est disponible en haut de la page \ref{fig:constraint_mgmt};
  \item les contraintes relatives au champ \textit{OBLIGATOIRE} d'un cours ou d'un module.
\end{itemize}

Comme expliqué dans la section \ref{prgrm_mgmt}, les contraintes temporelles sont gérées directement lorsqu'un cours est proposé à l'étudiant. En effet, une année se configure par semestre et, lorsque l'on configure le premier semestre par exemple, les cours du second semestre ne sont pas affichés. e 

C'est sur cette page \ref{fig:constraint_mgmt} que l'étudiant justifie \textbf{chacune des contraintes que son programme ne respecte pas}. Il n'est d'ailleurs pas possible d'envoyer le programme à la validation tant que chacune de ces exceptions n'a pas été justifiée.

\subsubsection{Négociation - Envoyer son programme à la validation}
 \label{validation_request}
Pour filtrer au maximum les demandes de validation et éviter ainsi de surcharger la commission de programme de requêtes inutiles, il n'est possible d'envoyer son programme à la validation que si certaines conditions sont respectées:
\begin{description}
  \item[avoir assez de crédits] le programme de l'étudiant doit respecter le minimum de crédits requis par le programme qu'il suit (dans le cas ou le programme ne propose pas suffisamment de cours, il suffit d'avoir autant de crédits que le programme en propose)
  \item[avoir accédé au menu de gestion des contraintes] à chaque fois que l'étudiant modifie son programme, il lui est demandé d'avoir visité au moins une fois la page relative à la vérification des contraintes pour pouvoir soumettre son programme;
  \item[ne pas avoir de dépendances non respectées ou avoir rempli le formulaire de justification] si le programme de l'étudiant comporte des contraintes non respectées, il lui est demandé de remplir un formulaire de justification dans le quel il doit justifier chacune des exceptions (contraintes non respectées);
  \item[ne pas avoir une requête en cours] si une requête a déjà été envoyée pour le programme, il n'est pas possible d'en envoyer une nouvelle tant que la précédente n'a pas été refusée ou acceptée par la commission de programme. Pour ne pas bloquer l'étudiant et demander à la commission de programme de faire plusieurs fois le travail de vérification, l'étudiant peut à tout moment annuler sa demande de validation, modifier son programme puis la renvoyer. 
\end{description} 

\subsection{Conclusion}
L'ensemble des fonctionnalités proposés aux deux types d'utilisateurs (étudiant et commission de programme) vient d'être présenté tout au long de cette section. Bien que cette section puisse servir de manuel, une version plus détaillée est présente en annexe expliquant plus en détail la démarche complète à suivre pour gérer les catalogues de cours et les programmes d'étudiant.

Notez que l'interface de l'application a été conçue pour être utilisée aussi bien sur un ordinateur que sur un smartphone. 

Cependant, il se peut que l'interface et certaines des fonctionnalités évoluent sensiblement suite au feedback récupéré après la remise des scénario de validation. 


% \subsection{Gestion des Données}
% \label{gestion_des_données}
% \subsubsection{Introduction}


% Il faut donc trouver un moyen de télécharger ces informations dans l'application. La solution la plus naïve serait de fournir des formulaires pour chaque entité (Cours, modules, ...) permettant d'ajouter une à une toute les informations nécessaire. Si l'on veut modifier les informations d'une entité, \textit{"il suffirait"} de naviguer dans les différents menu et de sélectionner le menu d'édition correspondant. Cependant cette solution n'atteint pas l'objectif fixé dans la solution, à savoir fournir un support pour enregistrer efficacement (et donc en peu de temps) les informations relatives aux curricula. Ajouter une à une toute les dépendances de cours peut être très ennuyant. 

% Une première amélioration que l'on peut ajouter à cette solution, est d'utiliser des formulaires excel pour ajouter ces informations. En créant une page par entité comme présenté sur l'image~\ref{fig:excel_example}, on pourrait ajouter toute les informations liés au modules, aux cours plus efficacement, l'import de fichier excel étant une chose assez aisée. 
% \begin{figure}[H]
% \centering
% \caption{Feuille Excel pour importer les données relatives aux modules}
% \label{fig:excel_example}
% \includegraphics[width=0.8\textwidth]{excel_example}
% \end{figure} 

% Bien que cela permette d'ajouter des informations de façon plus efficaces, il subsiste plusieurs problèmes
% \begin{itemize}
% \item C'est toujours aussi éprouvant d'ajouter les dépendances. Il toujours les ajouter une par une, bien que cela soit sur une seule page.
% \item On ne peut pas donner au formulaire (et le programme qui l'importe) le pouvoir de créer les entités car:
% \begin{itemize}
%   \item En cas de faute de frappe, il faudra de nouveau naviguer dans l'application pour supprimer les erreurs.
%   \item Il est très difficile et peu efficace de gérer les inclusions des cours(L'appartenance d'une entité à une autre, un cours à un module par example). Cela implique des recherches sur le nom des entités. De nouveau, en cas de faute de frappe, il faudra aller corriger les erreurs dans l'application
% \end{itemize}
% \end{itemize}

% Le catalogue de cours étant un graphe (Dont les nœuds sont des entités et les dépendances des arrêtes), une autre solution serait d'utiliser un logiciel qui permet d'en dessiner. Un graphe étant visuellement plus parlant  qu'un tableur, le nombre d'erreurs serait donc moindre. 

% Le principal problème de cette solution réside dans les informations que l'on peut mettre dans ce graphe. Certes, on pourrait \textit{bricoler} avec le logiciel pour ajouter des méta-données aux objets que l'on dessine, mais cela pourrait de nouveaux devenir très embêtant à utiliser et surtout relativement compliqué à importer. 
  
% La solution utilisée dans l'application est un compromis entre la solution \textit{"graphe"} et celle \textit{"excel"}. La gestion des données est subdivisées en deux processus:
% \begin{itemize}
% \item L'import de la structure du catalogue via un logiciel qui permet de dessiner des graphes
% \item L'ajout d'informations supplémentaires (Nom, crédits, ...) via un import de formulaire excel
% \end{itemize}
% \subsubsection{Pourquoi avoir subdiviser l'import des données en deux parties distinctes?}

% Pour rendre les choses plus aisées au personnel qui va encoder le programme, nous avons décidé d'utiliser yEd, un outil relativement haut niveau qui permet de générer des graphes. En peu de temps, il est possible de construire l'ensemble du programme de cours à l'aide de cet éditeur disponible sur Windows, Mac Os et Linux tout en sortant un diagramme clair et concis.


% \textbf{Pourquoi}? Car le programme de cours est un graphe, dont chaque nœud correspond à un cours et chaque \textit{edge}, à une dépendance. 

% La solution idéale serait d'avoir un logiciel qui, en plus d'être intégré à l'application serait totalement adapté à notre besoin, à savoir \textbf{dessiner un graphe de cours}. Cela serait un dessinateur de programme de cours à part entière, proposant des nœuds intitulés cours, des arrêtes pour exprimer les contraintes, une façon de regrouper ces nœuds en module, en plus d'une autre pour y ajouter des informations relatives aux crédits, au contraintes des modules, etc. Cependant, cela dépasse malheureusement le cadre de mon mémoire. Libre à un étudiant, féru de développement web, de s'y attaquer dans les années à venir.

% \subsubsection{Limites de la démarche}
% Pour revenir à la façon dont nous importons les données, la principale limite d'un outil de la sorte est que nous sommes limités dans l'information que nous pouvons mettre dans ce graphe. Certes, il serait possible de sélectionner les différents nœuds et modules un à un et d'y ajouter l'information nécessaire, mais cette solution n'est pas efficace. Ils existe des solutions plus efficaces pour gérer des données à grande échelle : Excel.

% La seconde limite, est qu'il faut se mettre d'accord sur l'utilisation de ce programme tiers afin de savoir \textit{quoi} parser. Tout cela sera détaillé dans un manuel disponible dans les annexes

% L'import des données se fait donc en deux temps. Le graphe, qui contient les informations sur la structure du catalogue de cours (Nom des différentes entités et des dépendances), est d'abord parsé par l'application pour en extraire les informations. En suite, les informations plus spécifiques du catalogue de cours (les propriétés diverses des entités; nom détaillé, url, date, informations sur les crédits) doivent être fournies via un formulaire Excel qui, à sont, tour doit être télécharger vers l'application.

% \subsubsection{Construction et Import de la structure du catalogue}
% L'idée est de construire le graphe de cours en utilisant une application externe. Les exigences pour ce logiciel sont les suivantes:
% \begin{itemize}
% \item  Avec ce logiciel, il doit être possible de grouper les différents nœuds pour représenter les curricula et leur différents modules.
% \item Le graphe étant relativement complexe, il est nécessaire d'avoir un outil qui arrive à construire une disposition correcte
% \item Il doit être possible d'exporter ces informations dans un format standard et aisé à parser. 
% \item Ce logiciel doit être disponible sur Mac Os, Linux et Windows. 
% \end{itemize}

% Plusieurs candidats on été retenus; yEd, Dia et Graphiz. Tout les trois sont disponibles aussi bien sur Windows et Mac os que sur Linux et permettent d'exporter dans un format standard : le xml, mais un seul d'entre-eux permet de restructurer dynamiquement la structure du graphe: yEd.

% C'est pourquoi notre choix c'est porté sur ce logiciel.

% L'idée, pour construire le catalogue de cours, est (Dans yEd)
% \begin{itemize}
% \item D'utiliser les nœuds pour ajouter des cours, et de les labelliser avec leur sigle.
% \item D'utiliser les différents types d'arêtes pour représenter les différents types de dépendances
% \item De mettre les nœuds dans des groupes (labellisés avec leur nom) et les groupes dans des autres groupes pour représenter les différents modules, sous modules et programmes
% \end{itemize}

% Après, on demande au programme de calculer un layout hiérarchique. Sur l'image suivante, vous pouvez voir une partie de ce que génère yEd. (Le programme entier est disponibles dans les annexes)
% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{ingi_sub_course_catalog}
% \caption{Exemple de graph généré par Yed}
% \label{fig:subcatalog}
% \end{figure}


% \subsubsection{Construction et Import du formulaire Excel}
% Comme expliqué précédemment, le graph à lui seul n'est pas suffisant pour ajouter toute les informations nécessaire à l'application. Le formulaire Excel est utilisé pour ajouter les informations relatives au propriétés des programmes, modules et cours des différents curricula. 

% Ces propriétés contiennent des informations simples sur les différents objets du catalogues comme le nom complet des différents cours, modules et programmes, les professeurs, les liens vers pages des cours. Elle contiennent aussi les informations relatives aux contraintes sur les propriétés, comme le nombre de crédits.

% Il n'y a aucune restrictions sur les informations qui peuvent être ajoutées ici. 

% La structure du document est la suivante~\ref{fig:excel_structure}. Tout d'abord, il y a une page par objet (Cours, Programme, Module, Sous-module)

% \begin{figure}[H]
% \centering
% \caption{Structure d'un formulaire Excel}
% \label{fig:excel_structure}
% \includegraphics[width=0.8\textwidth]{excel_structure}
% \end{figure}

% Chacune des pages est structurée comme illustré sur l'image~\ref{fig:excel_page_structure}. 

% \begin{figure}[H]
% \centering
% \caption{Structure de la page relatives aux cours du formulaire Excel}
% \label{fig:excel_page_structure}
% \includegraphics[scale=1]{excel_page_structure}
% \end{figure}

% La ligne 1, comprenant des cellules écrites en \textbf{gras} représente le header de la page. Chacune des cellules représente le nom de la propriété en question. Une propriété est un couple (Type, Value) où \textit{Type} correspond au nom de la propriété, et \textit{Value} à sa valeur. La première colomne représente la propriété qui \textbf{identifie} l'objet en question. Lorsque la page sera importé, une nouvelle propriété sera créée pour l'objet identifié par l'élément de la première colonne. La valeur de cette propriété sera la cellule traitée, et le type de la propriété le nom de la colonne. 

% Par exemple, pour la ligne 4 de la page~\ref{fig:excel_page_structure}
% Deux propriétés seront crées pour le cours intitulé \textit{SINF1103}
% \begin{enumerate}
% \item La propriété ayant pour type \textbf{CREDITS} avec comme valeur \textbf{5}.
% \item La propriété ayant pour type \textbf{PROFESSOR} avec comme valeur \textbf{KIM MENS}.
% \end{enumerate}

% Pour plus de facilité, il est possible de télécharger un \textit{template} de se formulaire depuis l'application, contenant toute les informations qui existe dans la base de données. 

% Par example, si l'on décide de télécharger ce template juste après avoir importer le graphe de cours, on aura les informations suivantes~\ref{fig:init_excel} pour les cours. 

% \begin{figure}[H]
% \caption{Formulaire excel téléchargé juste après importation du graphe}
% \label{fig:init_excel}
% \includegraphics[scale=0.8]{init_excel}
% \end{figure}

% Il suffira après à la commission de programme de compléter ce fichier avec les informations souhaitées et de le télécharger vers l'application.

%         